// Generated by gencpp from file balboa_core/balboaLL.msg
// DO NOT EDIT!


#ifndef BALBOA_CORE_MESSAGE_BALBOALL_H
#define BALBOA_CORE_MESSAGE_BALBOALL_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace balboa_core
{
template <class ContainerAllocator>
struct balboaLL_
{
  typedef balboaLL_<ContainerAllocator> Type;

  balboaLL_()
    : header()
    , arduinoMillis(0)
    , batteryMillivolts(0)
    , angleY(0)
    , angleX(0)
    , angleZ(0)
    , driveLeft(0)
    , driveRight(0)
    , speedLeft(0)
    , speedRight(0)
    , distanceLeft(0)
    , distanceRight(0)
    , sensorValue1(0)
    , sensorValue2(0)
    , sensorValue3(0)
    , sensorValue4(0)
    , sensorValue5(0)
    , ir(0)  {
    }
  balboaLL_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , arduinoMillis(0)
    , batteryMillivolts(0)
    , angleY(0)
    , angleX(0)
    , angleZ(0)
    , driveLeft(0)
    , driveRight(0)
    , speedLeft(0)
    , speedRight(0)
    , distanceLeft(0)
    , distanceRight(0)
    , sensorValue1(0)
    , sensorValue2(0)
    , sensorValue3(0)
    , sensorValue4(0)
    , sensorValue5(0)
    , ir(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int32_t _arduinoMillis_type;
  _arduinoMillis_type arduinoMillis;

   typedef int32_t _batteryMillivolts_type;
  _batteryMillivolts_type batteryMillivolts;

   typedef int32_t _angleY_type;
  _angleY_type angleY;

   typedef int32_t _angleX_type;
  _angleX_type angleX;

   typedef int32_t _angleZ_type;
  _angleZ_type angleZ;

   typedef int32_t _driveLeft_type;
  _driveLeft_type driveLeft;

   typedef int32_t _driveRight_type;
  _driveRight_type driveRight;

   typedef int32_t _speedLeft_type;
  _speedLeft_type speedLeft;

   typedef int32_t _speedRight_type;
  _speedRight_type speedRight;

   typedef int32_t _distanceLeft_type;
  _distanceLeft_type distanceLeft;

   typedef int32_t _distanceRight_type;
  _distanceRight_type distanceRight;

   typedef int32_t _sensorValue1_type;
  _sensorValue1_type sensorValue1;

   typedef int32_t _sensorValue2_type;
  _sensorValue2_type sensorValue2;

   typedef int32_t _sensorValue3_type;
  _sensorValue3_type sensorValue3;

   typedef int32_t _sensorValue4_type;
  _sensorValue4_type sensorValue4;

   typedef int32_t _sensorValue5_type;
  _sensorValue5_type sensorValue5;

   typedef int32_t _ir_type;
  _ir_type ir;





  typedef boost::shared_ptr< ::balboa_core::balboaLL_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::balboa_core::balboaLL_<ContainerAllocator> const> ConstPtr;

}; // struct balboaLL_

typedef ::balboa_core::balboaLL_<std::allocator<void> > balboaLL;

typedef boost::shared_ptr< ::balboa_core::balboaLL > balboaLLPtr;
typedef boost::shared_ptr< ::balboa_core::balboaLL const> balboaLLConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::balboa_core::balboaLL_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::balboa_core::balboaLL_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::balboa_core::balboaLL_<ContainerAllocator1> & lhs, const ::balboa_core::balboaLL_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.arduinoMillis == rhs.arduinoMillis &&
    lhs.batteryMillivolts == rhs.batteryMillivolts &&
    lhs.angleY == rhs.angleY &&
    lhs.angleX == rhs.angleX &&
    lhs.angleZ == rhs.angleZ &&
    lhs.driveLeft == rhs.driveLeft &&
    lhs.driveRight == rhs.driveRight &&
    lhs.speedLeft == rhs.speedLeft &&
    lhs.speedRight == rhs.speedRight &&
    lhs.distanceLeft == rhs.distanceLeft &&
    lhs.distanceRight == rhs.distanceRight &&
    lhs.sensorValue1 == rhs.sensorValue1 &&
    lhs.sensorValue2 == rhs.sensorValue2 &&
    lhs.sensorValue3 == rhs.sensorValue3 &&
    lhs.sensorValue4 == rhs.sensorValue4 &&
    lhs.sensorValue5 == rhs.sensorValue5 &&
    lhs.ir == rhs.ir;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::balboa_core::balboaLL_<ContainerAllocator1> & lhs, const ::balboa_core::balboaLL_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace balboa_core

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::balboa_core::balboaLL_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::balboa_core::balboaLL_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::balboa_core::balboaLL_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::balboa_core::balboaLL_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::balboa_core::balboaLL_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::balboa_core::balboaLL_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::balboa_core::balboaLL_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8094bd531a6fb751ecc5a7d5be735f40";
  }

  static const char* value(const ::balboa_core::balboaLL_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8094bd531a6fb751ULL;
  static const uint64_t static_value2 = 0xecc5a7d5be735f40ULL;
};

template<class ContainerAllocator>
struct DataType< ::balboa_core::balboaLL_<ContainerAllocator> >
{
  static const char* value()
  {
    return "balboa_core/balboaLL";
  }

  static const char* value(const ::balboa_core::balboaLL_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::balboa_core::balboaLL_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"int32 arduinoMillis\n"
"int32 batteryMillivolts\n"
"int32 angleY\n"
"int32 angleX\n"
"int32 angleZ\n"
"int32 driveLeft\n"
"int32 driveRight\n"
"int32 speedLeft\n"
"int32 speedRight\n"
"int32 distanceLeft\n"
"int32 distanceRight\n"
"\n"
"int32 sensorValue1\n"
"int32 sensorValue2\n"
"int32 sensorValue3\n"
"int32 sensorValue4\n"
"int32 sensorValue5\n"
"\n"
"int32 ir\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::balboa_core::balboaLL_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::balboa_core::balboaLL_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.arduinoMillis);
      stream.next(m.batteryMillivolts);
      stream.next(m.angleY);
      stream.next(m.angleX);
      stream.next(m.angleZ);
      stream.next(m.driveLeft);
      stream.next(m.driveRight);
      stream.next(m.speedLeft);
      stream.next(m.speedRight);
      stream.next(m.distanceLeft);
      stream.next(m.distanceRight);
      stream.next(m.sensorValue1);
      stream.next(m.sensorValue2);
      stream.next(m.sensorValue3);
      stream.next(m.sensorValue4);
      stream.next(m.sensorValue5);
      stream.next(m.ir);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct balboaLL_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::balboa_core::balboaLL_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::balboa_core::balboaLL_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "arduinoMillis: ";
    Printer<int32_t>::stream(s, indent + "  ", v.arduinoMillis);
    s << indent << "batteryMillivolts: ";
    Printer<int32_t>::stream(s, indent + "  ", v.batteryMillivolts);
    s << indent << "angleY: ";
    Printer<int32_t>::stream(s, indent + "  ", v.angleY);
    s << indent << "angleX: ";
    Printer<int32_t>::stream(s, indent + "  ", v.angleX);
    s << indent << "angleZ: ";
    Printer<int32_t>::stream(s, indent + "  ", v.angleZ);
    s << indent << "driveLeft: ";
    Printer<int32_t>::stream(s, indent + "  ", v.driveLeft);
    s << indent << "driveRight: ";
    Printer<int32_t>::stream(s, indent + "  ", v.driveRight);
    s << indent << "speedLeft: ";
    Printer<int32_t>::stream(s, indent + "  ", v.speedLeft);
    s << indent << "speedRight: ";
    Printer<int32_t>::stream(s, indent + "  ", v.speedRight);
    s << indent << "distanceLeft: ";
    Printer<int32_t>::stream(s, indent + "  ", v.distanceLeft);
    s << indent << "distanceRight: ";
    Printer<int32_t>::stream(s, indent + "  ", v.distanceRight);
    s << indent << "sensorValue1: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sensorValue1);
    s << indent << "sensorValue2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sensorValue2);
    s << indent << "sensorValue3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sensorValue3);
    s << indent << "sensorValue4: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sensorValue4);
    s << indent << "sensorValue5: ";
    Printer<int32_t>::stream(s, indent + "  ", v.sensorValue5);
    s << indent << "ir: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ir);
  }
};

} // namespace message_operations
} // namespace ros

#endif // BALBOA_CORE_MESSAGE_BALBOALL_H
